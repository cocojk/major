user_tables, user_constraints, user_views, user_synonyms, user_sequences


예제 11: 생산 부서와 연구개발 부서가 모두 위치해 있는 곳은 어디인가?


(부서위치)  /  ? 부서번호 (? 부서명 = ‘생산’ OR 부서명 = ‘연구개발’  (부서))
desc,asc

system catalog 


CONNECT SYSTEM/MIS12345; -> dba
CREATE USER TEST(id) IDENTIFIED BY TEST1234(비번);
GRANT DBA TO TEST;
GRANT CONNECT TO TEST;
CONNECT TEST/TEST1234;
ALTER USER SCOTT IDENTIFIED BY TIGER;
CREATE TABLE EMP AS SELECT * FROM SCOTT.EMP;

CREATE TABLE employee2
 (employeeid VARCHAR2(9) NOT NULL,
 fname VARCHAR2(8),
 minit VARCHAR2(2),
 lname VARCHAR2(8),
 bdate DATE,
 address VARCHAR2(27),
 sex VARCHAR2(1),
 salary NUMBER(7) NOT NULL,
 superempid VARCHAR2(9),
 dno NUMBER(1) NOT NULL,
 CONSTRAINT pk_employee PRIMARY KEY (employeeid),
 CONSTRAINT fk_department FOREIGN KEY (dno)
 REFERENCES department (dnumber) ON DELETE CASCADE);

insert into employee2  values
 ('123456789', 'Joe', 'M', 'Smith', '01-JUN-45',
 '123 Smith St.', 'm', 45000, '123456789', 1) ;
ALTER TABLE emp_department_1
 ADD (manager VARCHAR2(8)) ;
ALTER TABLE emp_department_1
 MODIFY (fname VARCHAR2(15));
ALTER TABLE PLAYER
RENAME COLUMN PLAYER_ID TO TEAM_ID;
ALTER TABLE PLAYER
ADD CONSTRAINT PLAYER_FK
   FOREIGN KEY (TEAM_ID) REFERENCES TEAM(TEAM_ID);

CREATE VIEW vw_emp_dno_1
     AS SELECT fname, lname, dno
     FROM employee1
     WHERE dno = 1;
UPDATE employee2            
          SET    salary = salary * 1.04            
          WHERE  dno = 1;
SELECT TO_CHAR(SYSDATE, ‘DD-MON-YYYY HH:MM:SS’) FROM DUAL

CREATE TABLE NASDAQ (
ID VARCHAR2(20),
TYPE VARCHAR2(20),
SYMBOL VARCHAR2(20),
DATES VARCHAR2(8),
OPEN NUMBER(20),
HIGH NUMBER(20),
LOW NUMBER(20),
CLOSE NUMBER(20), 
VOLUME NUMBER(20));

INSERT INTO department VALUES
       (seq_department_number.nextval, 'Finance',
        '123456789', '1999-01-01');

CREATE SEQUENCE sequence_name
    [START WITH n]
    [INCREMENT BY n]
    [MAXVALUE n | NOMAXVALUE]
    [MINVALUE n | NOMINVALUE]
    [CYCLE | NOCYCLE]
    [CACHE | NOCACHE]

CREATE SEQUENCE seq_department_number
      START WITH  1
      MAXVALUE    9999
      NOCYCLE;

SELECT seq_department_number.nextval FROM dual ;

SELECT sequence_name, min_value, max_value, last_number
     FROM USER_SEQUENCES ;

DROP SEQUENCE seq_department_number ;

CREATE SYNONYM employees2 FOR scott.employee1;

GRANT ALL ON  emp TO test

between A and B
not in ('서울','수원','인천')
is null

SELECT p.부품번호, 부품내역, 공급자번호
FROM   부품1 p LEFT JOIN 주문1 o
ON     p.부품번호 = o.부품번호;

결과:        부품번호       부품내역	공급자번호 
          ----------------------------------------------
               105            너트             16
               113            볼트		   null
               150             못              27
SELECT   <항목명 목록>          
FROM     <테이블명>          
WHERE    <항목명>  <비교연산자>  ALL/ANY/SOME 
                                 ( <SELECT 절>            
                                   <FROM   절>            
                                  [<WHERE  절>] );


SELECT p.부품번호, o.부품번호, 부품내역, 공급자번호
FROM   부품1 p FULL JOIN 주문1 o
ON     p.부품번호 = o.부품번호;

SELECT 부품번호, 재고량
         FROM   부품
         WHERE  NOT  EXISTS  (SELECT *
                              FROM   주문
                              WHERE  주문.부품번호 = 부품.부품번호);

SELECT  공급자번호
FROM    공급자
WHERE   위치 = ‘서울’
EXCEPT (Oracle의 경우 MINUS)
SELECT  공급자번호
FROM    주문
WHERE   부품번호 = 150;

부품번호 SMALLINT NOT NULL
         CHECK (부품번호 BETWEEN 100 AND 999);

FOREIGN KEY (부품번호) REFERENCES 부품 
    ON DELETE SET NULL 
    ON UPDATE CASCADE
선택사항
NO ACTION: 부모 레코드의 삭제 금지
CASCADE: 해당 자식 레코드를 자동 삭제
SET NULL: 자식 레코드의 해당 항목값을 공값화


API(Application Programming Interfaces)
데이터베이스 프로그램 라이브러리
제품마다 상이한 형식으로 인한 호환성 문제


ODBC(Open DataBase Connectivity)
상이한 SQL DBMS에 접근하는 공통의 인터페이스
국제적 표준과 호환성 유지


install.packages("sqldf")
library(sqldf)
stock <- read.csv("nasdaq.csv")
colnames(stock)
dim(stock)
sqldf("select count(*) from stock")
sqldf("select * from stock limit 10")
sqldf("select symbol,count(*) from stock group by symbol having count(*) < 10")
min(stock$dates)
max(stock$dates)
sqldf("select dates, count(*) from stock where dates>201603 group by dates")
str(stock)
stock$dates <- as.character(stock$dates)
stock$date <- paste(substr(stock$dates,1,4),substr(stock$dates,5,6),substr(stock$dates,7,8),sep="-")
str(stock)
dateList <- sqldf("select distinct date date from stock")
head(dateList)
dim(dateList)
dateList$seq <- 1:dim(dateList)[1]
head(dateList)
stock1 <- sqldf("select a.*, b.seq from stock a, dateList b where a.date=b.date")
head(stock1)
colnames(stock1)
stock2 <- stock1[,-c(1,4)]
colnames(stock2)
target <- sqldf("select a.*, b.high/a.close margin from stock2 a, stock2 b where a.symbol=b.symbol and a.seq=b.seq-1")
head(target)
summary(target$margin)
target1 <- sqldf("select date, seq, symbol, case when margin>1.03 then 'yes' else 'no' end class from target")
head(target1)
table(target1$class)
prop.table(table(target1$class))
mart1 <- sqldf("select a.*, b.open, b.high, b.low, b.close, b.volume from target1 a, stock b where a.date=b.date and a.symbol=b.symbol")
colnames(mart1)
sqldf("select count(*) from stock")
sqldf("select * from stock limit 10")
sqldf("select symbol,count(*) from stock group by symbol having count(*) < 10")
a_stock <- sqldf("select symbol, avg(close) avg_close from stock where symbol like 'A%' group by symbol")
head(a_stock,5)
tail(a_stock,10)
sqldf("select min(dates), max(dates) from stock")
sqldf("select * from (select symbol, avg(close) avg_close, max(close) max_close from stock group by symbol) where symbol like 'B%'  order by max_close desc limit 10")